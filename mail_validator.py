#!/usr/bin/env python
# $Id: mail_validator.py 84690 2014-04-16 10:16:57Z tvollmer $

import argparse
import os
import sys
import socket
import smtplib
import imaplib
import time
import re
import dkim

from email.MIMEText import MIMEText
from email import Utils
from datetime import datetime, timedelta

RETURN_OK = 0
RETURN_WARNING = 1
RETURN_CRITICAL = 2
RETURN_UNKNOWN = 3
KEY_MAX_AGE = 180


class SmtpSender(object):
    def __init__(self, options):
        self.__local_hostname = socket.gethostname()
        self.__host = options.smtp_host
        self.__port = options.smtp_port
        self.__mail_from = options.sender
        self.__rcpt_to = options.to
        self.__test = options.validate
        self.__message = "This is a autogenerated message for mail verification tests"

    def __del__(self):
        if hasattr(self, '__smtp_connection'):
            self.__smtp_connection.quit()

    def connect(self):
        """
        Purpose: Establish smtp connection to the target server
        Returns: Status, Message
        """

        try:
            self.__smtp_connection = smtplib.SMTP(self.__host, self.__port)
        except:
            return RETURN_UNKNOWN, "Could not connect to SMTP host."

        return RETURN_OK, ""

    def compose_mail(self):
        """
        Purpose: Compose the complete mail, including header and body
        Returns: The body as an MIMEText object
        """

        message_id = Utils.make_msgid()
        body = MIMEText(self.__message)
        body['Subject'] = '%s test mail from %s[%s]' % (self.__test, __file__, self.__local_hostname)
        body['Date'] = Utils.formatdate(localtime=1)
        body['From'] = self.__mail_from
        body['To'] = self.__rcpt_to
        body['Message-ID'] = message_id

        return body

    def send_test_mail(self):
        """
        Purpose: Send a normal test mail to the given smtp host
        Returns: Status, Message ID
        """

        body = self.compose_mail()
        try:
            self.__smtp_connection.sendmail(self.__mail_from, self.__rcpt_to, body.as_string())
        except:
            return RETURN_UNKNOWN, 'Could not send message'

        return RETURN_OK, body['Message-ID']


class ImapReceiver:
    def __init__(self, host, user, password, mailbox):
        self.__host = host
        self.__user = user
        self.__password = password
        self.__mailbox = mailbox

    def __del__(self):
        if hasattr(self, '__imap_connection'):
            self.__imap_connection.logout()
            self.__imap_connection.close()

    def connect(self):
        """
        Purpose: Establish imap connection to the target server
        Returns: Status, Message
        """

        try:
            self.__imap_connection = imaplib.IMAP4(self.__host)
            self.__imap_connection.login(self.__user, self.__password)
            self.__imap_connection.select(self.__mailbox)

        except Exception:
            return RETURN_WARNING, 'Error connecting to the IMAP server %s: %s' % (self.__host)

        return RETURN_OK, ''

    def get_test_message(self, message_id):
        """
        Purpose: Read out the entire message (with given message id) via imap
        Returns: Status, Message
        """

        searchspec = "(HEADER Message-ID %s )" % message_id
        (typ, searchresult) = self.__imap_connection.search(None, searchspec)
        msg_number = searchresult[0]

        if not msg_number:
            return RETURN_WARNING, 'Send message not found in Mailbox'

        (typ, data) = self.__imap_connection.fetch(msg_number, '(RFC822)')
        return RETURN_OK, data[0][1]


class Validator:
    def validate_message(self, message, options, output):
        if options.validate == 'dkim':
            return self.verify_dkim(message, options, output)
        elif options.validate == 'tls':
            return self.verify_tls(message)

    def verify_dkim(self, body, options, output):
        """
        Purpose: Verify DKIM Signature
        Returns: Status, Message
        """
        match = re.search('d=[^;]+; s=(\d{14});', body)
        if not match:
            # Enable the next line, if no dkim signature should only be a warning.
            # return RETURN_WARNING, "No dkim signature found"
            return RETURN_CRITICAL, "No dkim signature found"
        selector = match.group(1)
        if dkim.verify(body): #, debuglog=output):
            if (datetime.now() - datetime.strptime(selector, '%Y%m%d%H%M%S')) > timedelta(days=KEY_MAX_AGE):
                return RETURN_CRITICAL, 'DKIM key (%s) older than %s days' % (selector, KEY_MAX_AGE)

            return RETURN_OK, 'DKIM verification successful, selector is %s' % selector
        else:
            return RETURN_CRITICAL, 'DKIM verification failed'

    def verify_tls(self, body):
        """
        Purpose: Verify TLS Log in Mail headers
        Returns: Status, Message
        """
        match = re.search('(using .* with cipher .*)\)', body)
        if not match:
            # Enable the next line, if no tls log should only be a warning.
            # return RETURN_WARNING, "No TLS log found"
            return RETURN_CRITICAL, "No TLS log found"
        cipherlog = match.group(1)
        return RETURN_OK, "TLS verification successful, mail was sent %s" % cipherlog


def init_cmd_options():
    """
    Purpose: Initialize and then get the commandline options
    Returns: Dictionary with the parsed options and their values
    """

    parser = argparse.ArgumentParser(
        description='Send mail from a testserver, retrieve the sent mail via IMAP and validate either DKIM or TLS.')
    parser.add_argument("-s", "--smtp_host",
                        action="store",
                        default="localhost",
                        help="SMTP hostname (default=localhost)")
    parser.add_argument("-p", "--smtp_port",
                        action="store",
                        help="SMTP port (default=25)",
                        default="25")
    parser.add_argument("-i", "--imap_host",
                        action="store",
                        default="localhost",
                        help="IMAP hostname (default=localhost)")
    parser.add_argument("-u", "--user",
                        action="store",
                        required=True,
                        help="IMAP user")
    parser.add_argument("-P", "--password",
                        action="store",
                        required=True,
                        help="IMAP password")
    parser.add_argument("-m", "--mailbox",
                        action="store",
                        required=True,
                        help="IMAP mailbox/Folder")
    parser.add_argument("-f", "--from",
                        action="store",
                        dest="sender",
                        default="tester@tester.invalid",
                        help="Sender adress")
    parser.add_argument("-t", "--to",
                        action="store",
                        default="tester@tester.invalid",
                        help="Recipient adress")
    parser.add_argument("-o", "--output",
                        action="store",
                        choices=[None, 'nagios', 'integration'],
                        help="Which output format should be used. (default=None)",
                        default=None)
    parser.add_argument("validate",
                        action="store",
                        choices=['dkim', 'tls'],
                        help="Which Test should be executed.")

    return(parser.parse_args())


def exit(type, message, format):
    """
    Purpose: Format and output the message depending on the output option
    Returns: Nothing
    """

    status = 'ERROR'
    if type == RETURN_OK:
        status = 'SUCCESS'

    if format == "nagios":
        string = "Status %s - %s\n" % (status, message)
    elif format == "integration":
        string = "##teamcity[message text='%s' status='%s']\n" % (message, status)
    else:
        sys.exit(type)

    sys.stdout.write(string)
    sys.exit(type)


def main():
    """
    Purpose: Send an autogenerated test mail via smtp to target host
             and retrieve the mail from imap server. After that validate
             the dkim signing of this mail content
    Returns: Nothing
    """

    options = init_cmd_options()

    smtp = SmtpSender(options)
    mail_validator = Validator()

    return_code, content = smtp.connect()
    if return_code != RETURN_OK:
        exit(return_code, content, options.output)

    return_code, message_id = smtp.send_test_mail()
    if return_code != RETURN_OK:
        exit(return_code, message_id, options.output)

    #TODO: Rewrite to polling.
    time.sleep(6)

    imap = ImapReceiver(options.imap_host, options.user, options.password, options.mailbox)

    return_code, content = imap.connect()
    if return_code != RETURN_OK:
        exit(return_code, content, options.output)

    return_code, mail = imap.get_test_message(message_id)
    if return_code != RETURN_OK:
        exit(return_code, '%s "%s"' % (mail, options.mailbox), options.output)

    if options.output == 'integration':
        output = os.fdopen(sys.stdout.fileno(), 'w', 0)
    else:
        output = None

    return_code, message = mail_validator.validate_message(mail, options, output)
    exit(return_code, message, options.output)

if __name__ == "__main__":
    main()
